# senior-design-project_23
## Title:
ENHANCING SPEECH IN REAL-TIME: USING DENSE NEURAL NETWORKS WITH DILATED CONVOLUTIONS AND SQUEEZED TEMPORAL CONVOLUTIONAL MODULES IN THE TIME DOMAIN.
### Abstract:
we present a fully convolutional neural network for enhancing real-time speech in the time domain. Skip connections are included in the architecture of the proposed encoder-decoder network. The layers in the decoder and encoder are down the lined by densely connected blocks (DCB) made of causal and dilated convolutions. These dilated convolutions facilitate the aggregation of contextual information across multiple resolutions. The network is ideal for real-time applications due to the causal convolutions' utilization of information inflow prevention from subsequent frames. Additionally, we propose employing up sampling in the decoder with sub-pixel convolutional layers. We also proposed employing a Squeezed temporal convolutional network (STCNs) after every dense block in encoder and decoder. To train the model, a loss function consisting of two components is also utilized: a loss in both the frequency domain and the time domain. The model performs better than the time-domain loss using the proposed loss function. According to experimental outcomes, the suggested model greatly surpasses previous state-of-the-art models in quality scores as well as objective intelligibility in real-time scenarios.
### The proposed densely connected networks.
With a network that is densely connected, each layer's input receives data from all the preceding layers concatenated together. This approach offers a pair of major advantages. First, the vanishing gradient issue is avoided by the dense connections to each of the preceding layers. Second, it is found that a narrower dense network outperforms a broader normal network, thereby increasing the network's parameter efficiency.
            In the proposed approach, we suggest a dense block with dilated connections be applied after every layer in both the decoder and the encoder. There are five 2-dimensional convolutional layers in each dense block. The causal convolutions ensure that the suggested method is appropriate for real-time application. Therefore, the interframe convolutions are causal. After every convolution, parametric ReLU (PReLU) nonlinearity and layer normalization is applied. The dilation rates are set at 1, 2, 4, 8, and 16 in each dense block.
                                  
                 
### The proposed sub-pixel convolutions.
Within a convolutional neural network, sub-pixel convolutions, which are learnable, are employed as an up-sampling layer. In order to prevent checkerboard artifacts, subpixel convolution is used in this paper as a better replacement for transposed convolution. Firstly, an input speech signal is up sampled by adding zeros amid the subsequent samples in a transposed convolution, then a convolutional layer is used to generate a signal with non-zero elements. For a non-symmetric configuration that yields checkerboard artifacts, the filter length should be a factor of the filter stride. Sub-pixel convolution involves applying convolution to the original signal (no zeros are inserted) and multiplying the output channel count by the up-sampling rate to effectively increase the channel count.
            To obtain the necessary up sampled signal, the additional channels are reshaped. Figure 3 illustrates the up sampling of a 1-dimensional signal by a two-fold increase using sub-pixel convolution.


### The proposed model architecture.
The Figure 4 displays the architectural diagram of the model layout. The model is made up of the following layers: input, encoder, dense and dilated blocks, decoder, and output. Except for the output layer, all convolutions adhere to PReLU nonlinearity and layer normalization.
        The size of the model's input is [size of the batch, 1, number of frames, size of the frame]. Filters of size (1, 1) are used in the input layer to raise the total number of channels to 64. A dense block follows the input layer. Filters with a size of (2, 3) and 64 output channels are utilized for convolutions in all densely connected blocks.
           In the encoding phase of the proposed model, the dimension reduces initially at every layer (down sampling) along the frame axis by half while employing a convolution with filters of size (1, 3) and a stride of (1, 2). A dense block follows the down sampling.  The encoder's dense blocks at the end of each layer aid with context aggregation at various resolutions. The encoder has six layers of this type, and its ultimate output is [size of the batch, 64, number of frames, (size of the frame)/64].
            The size of the signal is gradually rebuilt to its original size by the decoder using dense blocks and sub-pixel convolutions. Each layer in the decoder receives its input data from the concatenation, which is in parallel with the channel axis, of the output from the layer before it and the output data from the equivalent symmetrical layer present in the encoder. The size of the input along its frame axis is doubled by sub-pixel convolutions using filters of size (1, 3). Lastly, the output layer outputs the enhanced frames by a single channel using filters of size (1, 1).
            To accommodate the time-varying nature of speech, we incorporate two GRU layers between the encoder and decoder. The frequency dimensions are expanded to match the input shape needed by the GRU. The encoder output's depth dimension is transformed into a series of feature vectors before being fed into the GRU layers. Following the GRU layers, the output sequence is reshaped to fit the decoder. GRU employs two gates, as opposed to LSTM's three gates, which reduces network complexity and enhances performance. Each layer effectively captures the temporal dynamics of speech.

 ### The proposed squeezed temporal convolutional modules.
The temporal convolutional modules (TCMs) have been extensively used recently in tasks involving speech distinction and target speaker identification. TCMs can achieve equivalent or even higher performance in time sequence modelling than LSTMs, and because they employ parallelable convolutions, less inference time is required. STCM, a lightweight TCN that reduces the number of parameters by squeezing the features into a smaller dimension with a dilated convolution, make up a STCN. To achieve a broad temporal receptive field, we employ STCN as the sequential module, which is applied after each dense block in the proposed model. Each STCN stacks 5 STCM units with an exponentially rising dilation rate d=1, 2, 4, 8, 16 as shown in Figure 5.
            The network can enhance speech information recovery by using the connection between several temporal scales. Figure 6 shows that STCM consists of three convolutions: an input 1x1 convolution, a gated depth-wise dilated convolution (GDDC), and an output 1x1 convolution. The input and output 1x1 convolutions are used to squeeze and restore the feature dimension, respectively, and GDDC differs from depth-wise dilated convolution in traditional TCM in three ways.
            First, the speech spectrum is time-frequency sparse, the DCC layer in the GDDC is less efficient at accurately capturing the information. In addition, GDDC adds a gating branch to let the gradient back-propagation process flow with information. In order to change the characteristic distribution of the main branch, the gating branch uses the sigmoid activation function to convert the output of DCC to the values (0, 1). To enhance network convergence, it is important to include layer normalization and PReLU layers between consecutive convolutional layers.
                                         
### The proposed loss functions.
We integrate two losses during the training of the model. Firstly, the overlap-and-add method is used to convert the enhanced frames into a waveform. To determine the loss at the level of utterances in the time domain, the mean squared error of the clean and enhanced utterances is used. The loss in the time-domain is expressed as: 
                                             l_t (h,h ̂) =  (1 )/l ∑_(n=0)^(l-1)▒〖〖(h_i [n] - h ̂_i  [n])〗^2  〗                            (1)
             L represents the length of utterance,            
             h[n] refers to the nth sample of the clean utterance and,
             h ̂[n] represents the nth sample of the enhanced utterance.
            Secondly, using l1 loss over the l1 norm of the STFT coefficients, we perform STFT on the utterances. The loss in the frequency domain is expressed as:
             l_f (h,h ̂) =  (1 )/(T·F) ∑_(t=1)^T▒〖∑_(f=1)^F▒〖 |[|〖H(x,y)〗_r | + |〖H(x,y)|〗_i]-[|〖H ̂(x,y)〗_r | + |〖H ̂(x,y)〗_i]| 〗  〗          (2)
              T represents total frame count,
              F represents the frequency bin count,       
              H (x, y) refers to the STFTs of h of T-F units,
            H ̂(x, y) represents the STFTs of h ̂ of T-F units and,
            The imaginary and real components of a complex variable H are represented as Hi and Hr, respectively
            Ultimately, the losses in the frequency and time domains are integrated as follows:
                             l(h,h ̂ )= (1 - β)* l_f (h,h ̂ )+ β * l_t (h,h ̂ )                                                          (3)
Where, β is a tailored hyper-parameter for the validation set.
